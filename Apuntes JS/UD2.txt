================================================================
   APUNTES DE ESTUDIO: DESARROLLO WEB CLIENTE (JS) - EXAMEN
================================================================

----------------------------------------------------------------
2.1 FORMULARIOS EN EL DOM
----------------------------------------------------------------
El navegador organiza los formularios en una estructura jer√°rquica.

[1] ACCESO A FORMULARIOS
------------------------
Existen dos formas principales de acceder a la etiqueta <form>:

A. Por ID o Selector (Forma Moderna):
   const form = document.getElementById('miForm');
   const form = document.querySelector('#miForm');

B. Colecci√≥n document.forms (Forma Cl√°sica):
   document.forms[0];            // Primer formulario del documento
   document.forms['nombreForm']; // Acceso por el atributo name=""

[2] ACCESO A ELEMENTOS DEL FORMULARIO
-------------------------------------
Una vez capturado el formulario, accedemos a sus controles (inputs, selects, buttons).

- Colecci√≥n .elements:
  const emailInput = formulario.elements.email; // Accede al input name="email"

- Propiedades clave de los controles:
  .value     -> Obtiene o define el texto escrito.
  .checked   -> true/false (para Checkbox y Radio).
  .type      -> Tipo de input (text, password, etc.).
  .disabled  -> true para desactivar el campo.


----------------------------------------------------------------
2.2 EVENTOS
----------------------------------------------------------------
Los eventos permiten ejecutar c√≥digo cuando ocurre una acci√≥n.

[1] MANEJO DE EVENTOS (Event Listeners)
---------------------------------------
Sintaxis est√°ndar:
elemento.addEventListener('tipo_evento', callback);

Eventos comunes:
- click            (al pulsar rat√≥n)
- submit           (al enviar formulario)
- input            (al escribir, en tiempo real)
- change           (al confirmar cambio o perder foco)
- DOMContentLoaded (cuando el HTML ha cargado)

[2] EL OBJETO EVENTO (e)
------------------------
El navegador pasa autom√°ticamente un objeto con detalles a la funci√≥n callback.

- e.target:        El elemento exacto donde ocurri√≥ el evento.
- e.currentTarget: El elemento que tiene el listener asignado.

[3] FLUJO: PROPAGACI√ìN Y CAPTURA
--------------------------------
El evento viaja por el DOM en tres fases:
1. Captura:  Baja desde window hasta el objetivo.
2. Objetivo: Llega al elemento.
3. Burbujeo (Bubbling): Sube desde el objetivo hasta window (Por defecto).

M√©todos de control:
- e.stopPropagation(): Detiene el burbujeo (el evento no sube a los padres).
- e.preventDefault():  Evita la acci√≥n nativa (ej: evita que submit recargue la p√°gina).

[4] DELEGACI√ìN DE EVENTOS
-------------------------
T√©cnica de optimizaci√≥n: poner un solo listener en el padre para manejar muchos hijos.
Ejemplo: Poner el click en <ul> para detectar clicks en los <li> usando e.target.


----------------------------------------------------------------
2.3 EXPRESIONES REGULARES (RegExp) - TEMA CLAVE
----------------------------------------------------------------
Patrones para b√∫squeda y validaci√≥n de texto.

[1] CREACI√ìN
------------
- Literal:     const regex = /patr√≥n/banderas;
- Constructor: const regex = new RegExp('patr√≥n', 'banderas');

[2] BANDERAS (FLAGS)
--------------------
- i : Insensitive (Ignora may√∫sculas/min√∫sculas).
- g : Global (Busca todas las coincidencias).
- m : Multiline (Inicio ^ y fin $ afectan a cada l√≠nea).

[3] SINTAXIS B√ÅSICA (CHEATSHEET)
--------------------------------
^        : Inicio de cadena.
$        : Fin de cadena.
.        : Cualquier car√°cter (salvo salto de l√≠nea).
\d       : D√≠gito [0-9].
\w       : Alfanum√©rico [A-Za-z0-9_].
\s       : Espacio en blanco.
* : 0 o m√°s veces.
+        : 1 o m√°s veces.
?        : 0 o 1 vez (Opcional).
{n,m}    : Entre n y m veces.
[...]    : Lista permitida (ej: [aeiou]).
[^...]   : Negaci√≥n (ej: [^0-9] nada que sea n√∫mero).

[4] M√âTODOS PRINCIPALES
-----------------------
- regex.test(texto) : Devuelve true/false. (VALIDACI√ìN).
- texto.match(regex): Devuelve array con coincidencias.
- texto.replace(regex, nuevo): Reemplaza texto.


----------------------------------------------------------------
PROFUNDIZACI√ìN: VALIDACI√ìN DE CONTRASE√ëAS (LOOKAHEADS)
----------------------------------------------------------------
Para validar reglas complejas (ej: "debe contener una may√∫scula") sin importar el orden,
se usan los "Lookaheads Positivos": (?=...)
Concepto: Mira adelante para ver si existe el patr√≥n, pero NO consume caracteres
y vuelve al inicio para comprobar la siguiente condici√≥n.

[NIVEL 1] Contrase√±a B√°sica
Requisito: 6 a 12 caracteres alfanum√©ricos.
Regex: /^[a-zA-Z0-9]{6,12}$/

[NIVEL 2] Contrase√±a Media
Requisito: M√≠nimo 8 caracteres y al menos un n√∫mero.
Regex: /^(?=.*\d).{8,}$/
Explicaci√≥n:
  (?=.*\d) -> ¬øHay un n√∫mero en alg√∫n sitio?
  .{8,}    -> Si s√≠, valida que haya 8 o m√°s caracteres.

[NIVEL 3] Contrase√±a Fuerte (Est√°ndar)
Requisito: M√≠nimo 8 chars, 1 min√∫scula, 1 may√∫scula, 1 n√∫mero.
Regex: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/

[NIVEL 4] Contrase√±a Ultra Segura
Requisito: Todo lo anterior + 1 car√°cter especial ($@$!%*?&).
Regex: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&]).{8,}$/

EJEMPLO DE C√ìDIGO JS:
function validar(password) {
    const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
    return regex.test(password); // Devuelve true o false
}



üü¢ ¬øQu√© son los par√©ntesis () en Expresiones Regulares?
En el mundo de las RegExp, los par√©ntesis tienen dos funciones principales: Agrupar y Capturar.

1. Agrupar (Para aplicar l√≥gica a un bloque)
Sirven para tratar varios caracteres como una √∫nica unidad. Es vital cuando usas cuantificadores (como *, + o ?).

Sin par√©ntesis: ab+

Significa: una "a" seguida de una o m√°s "b".

Coincide con: "ab", "abb", "abbb".

Con par√©ntesis: (ab)+

Significa: el grupo "ab" repetido una o m√°s veces.

Coincide con: "ab", "abab", "ababab".

2. Capturar (Extracci√≥n de datos)
Esta es la funci√≥n m√°s potente en JavaScript. Lo que pongas entre par√©ntesis se guarda en una memoria temporal. Cuando usas .exec() o .match(), JavaScript te devuelve un array donde:

Posici√≥n [0]: La coincidencia completa.

Posici√≥n [1]: Lo que hab√≠a dentro del primer par√©ntesis ( ).

Posici√≥n [2]: Lo que hab√≠a dentro del segundo par√©ntesis ( ).

Ejemplo visual: Imaginas que quieres validar una fecha y adem√°s extraer el d√≠a, el mes y el a√±o por separado.

const regex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
//              ^^^^^   ^^^^^   ^^^^^
//             Grupo 1 Grupo 2 Grupo 3



Ejemplo 1: Validar y extraer partes de una Fecha (DD/MM/AAAA)
Objetivo: Validar formato y separar d√≠a, mes y a√±o.

JavaScript

// Explicaci√≥n:
// ^      -> Inicio
// (\d{2})-> Grupo 1: Dos d√≠gitos (D√≠a)
// \/     -> La barra literal (hay que escaparla con contrabarra)
// (\d{2})-> Grupo 2: Dos d√≠gitos (Mes)
// \/     -> Barra literal
// (\d{4})-> Grupo 3: Cuatro d√≠gitos (A√±o)
// $      -> Fin

const regexFecha = /^(\d{2})\/(\d{2})\/(\d{4})$/;
const fecha = "25/12/2023";

const resultado = regexFecha.exec(fecha);

if (resultado) {
    console.log("Fecha v√°lida");
    console.log("D√≠a:", resultado[1]); // "25"
    console.log("Mes:", resultado[2]); // "12"
    console.log("A√±o:", resultado[3]); // "2023"
}